import { Component, Input, OnInit, inject, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import {
  IonContent, IonHeader, IonTitle, IonToolbar, IonButton, IonIcon, IonItem, IonLabel,
  IonModal, IonButtons, IonCard, IonCardHeader, IonCardTitle, IonCardContent,
  IonBadge, IonChip, IonTextarea, IonSelect, IonSelectOption,
  IonRefresher, IonRefresherContent, IonSegment, IonSegmentButton
} from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';
import {
  close, person, calendar, time, checkmarkCircle, closeCircle,
  chatbubbles, send, eye, eyeOff, business, people, shieldCheckmark,
  chevronDown, chevronUp, star, heart, add, arrowForward, informationCircle,
  chatbubblesOutline } from 'ionicons/icons';
import { AbsenceService } from 'src/app/core/services/absence.service';
import { Absence, AbsenceComment, CommentRequest } from 'src/app/core/interfaces/absence.types';

@Component({
  selector: 'app-absence-detail-modal',
  templateUrl: './absence-detail-modal.component.html',
  styleUrls: ['./absence-detail-modal.component.scss'],
  standalone: true,
  imports: [
    CommonModule, FormsModule, ReactiveFormsModule,
    IonContent, IonHeader, IonTitle, IonToolbar, IonButton, IonIcon, IonItem, IonLabel,
    IonModal, IonButtons, IonCard, IonCardHeader, IonCardTitle, IonCardContent,
    IonBadge, IonChip, IonTextarea, IonSelect, IonSelectOption,
    IonRefresher, IonRefresherContent, IonSegment, IonSegmentButton
  ],
})
export class AbsenceDetailModalComponent implements OnInit {
  @Input() absence: Absence | null = null;
  @Input() isOpen = false;

  private readonly absenceService = inject(AbsenceService);
  private readonly fb = inject(FormBuilder);

  // Signals
  comments = signal<AbsenceComment[]>([]);
  isLoading = signal(false);
  isSubmittingComment = signal(false);
  commentFilter = signal<string>('all');

  // Form
  commentForm: FormGroup;

  // Computed
  filteredComments = computed(() => {
    const filter = this.commentFilter();
    const allComments = this.comments();
    
    if (filter === 'all') {
      return allComments;
    }
    
    return allComments.filter(comment => comment.comment_type === filter);
  });

  constructor() {
    addIcons({
      close, person, calendar, time, checkmarkCircle, closeCircle,
      chatbubbles, send, eye, eyeOff, business, people, shieldCheckmark,
      chevronDown, chevronUp, star, heart, add, arrowForward, informationCircle,
      chatbubblesOutline
    });

    this.commentForm = this.fb.group({
      comment: ['', [Validators.required, Validators.minLength(3)]],
      type: ['employee', Validators.required],
      is_internal: [false]
    });
  }

  ngOnInit() {
    if (this.absence?.id) {
      this.loadComments();
    }
  }

  async loadComments() {
    if (!this.absence?.id) return;
    
    this.isLoading.set(true);
    try {
      const comments = await this.absenceService.getComments(this.absence.id);
      this.comments.set(comments);
    } catch (error) {
      console.error('Error loading comments:', error);
    } finally {
      this.isLoading.set(false);
    }
  }

  async submitComment() {
    if (this.commentForm.invalid || !this.absence?.id) return;

    this.isSubmittingComment.set(true);
    try {
      const commentData: CommentRequest = {
        comment: this.commentForm.value.comment,
        comment_type: this.commentForm.value.type,
        is_internal: this.commentForm.value.is_internal
      };

      const newComment = await this.absenceService.addComment(this.absence.id, commentData);
      
      // Add new comment to the list
      this.comments.update(comments => [...comments, newComment]);
      
      // Reset form
      this.commentForm.reset({
        comment: '',
        type: 'employee',
        is_internal: false
      });
    } catch (error) {
      console.error('Error adding comment:', error);
    } finally {
      this.isSubmittingComment.set(false);
    }
  }

  filterComments(event: any) {
    this.commentFilter.set(event.detail.value);
  }

  closeModal() {
    // Reset component state
    this.comments.set([]);
    this.commentFilter.set('all');
    this.commentForm.reset({
      comment: '',
      type: 'employee',
      is_internal: false
    });
  }

  async refresh(event: any) {
    await this.loadComments();
    event.target.complete();
  }

  // Helper methods
  getAbsenceIcon(): string {
    if (!this.absence?.absence_type) return 'calendar';
    
    const iconMap: { [key: string]: string } = {
      'Urlaub': 'sunny',
      'Krank': 'medkit',
      'Fortbildung': 'school',
      'Dienstreise': 'airplane',
      'Sonderurlaub': 'heart',
      'Gleitzeit': 'time',
      'Homeoffice': 'home'
    };
    
    return iconMap[this.absence.absence_type.display_name] || 'calendar';
  }

  getStatusColor(status: string): string {
    const colorMap: { [key: string]: string } = {
      'pending': 'warning',
      'approved': 'success',
      'rejected': 'danger',
      'cancelled': 'medium',
      'completed': 'success'
    };
    return colorMap[status] || 'medium';
  }

  getStatusText(status: string): string {
    const textMap: { [key: string]: string } = {
      'pending': 'Ausstehend',
      'approved': 'Genehmigt',
      'rejected': 'Abgelehnt',
      'cancelled': 'Storniert',
      'completed': 'Abgeschlossen'
    };
    return textMap[status] || status;
  }

  getCommentTypeColor(type: string): string {
    const colorMap: { [key: string]: string } = {
      'employee': 'success',
      'supervisor': 'warning',
      'hr': 'danger'
    };
    return colorMap[type] || 'primary';
  }

  getCommentTypeLabel(type: string): string {
    const labelMap: { [key: string]: string } = {
      'employee': 'Mitarbeiter',
      'supervisor': 'Vorgesetzter',
      'hr': 'HR'
    };
    return labelMap[type] || type;
  }

  formatDate(dateString: string): string {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('de-DE', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  }

  getDurationText(): string {
    if (!this.absence?.duration_days) return '';
    const days = this.absence.duration_days;
    return `${days} ${days === 1 ? 'Tag' : 'Tage'}`;
  }
}
